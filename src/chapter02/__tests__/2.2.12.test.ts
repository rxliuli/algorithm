/*
TODO 2.2.12　次线性的额外空间。用大小 M 将数组分为 N/M 块（简单起见，设 M 是 N 的约数）。实现一个归并方法，使之所需的额外空间减少到 \max(M,N/M)：(i) 可以先将一个块看做一个元素，将块的第一个元素作为块的主键，用选择排序将块排序；(ii) 遍历数组，将第一块和第二块归并，完成后将第二块和第三块归并，等等。

TODO 2.2.12　次线性的额外空间。用大小 M 将数组分为 N/M 块（简单起见，设 M 是 N 的约数）。实现一个归并方法，使之所需的额外空间减少到 \max(M,N/M)：(i) 可以先将一个块看做一个元素，将块的第一个元素作为块的主键，用选择排序将块排序；(ii) 遍历数组，将第一块和第二块归并，完成后将第二块和第三块归并，等等。

TODO 2.2.13　平均情况的下限。请证明任意基于比较的排序算法的预期比较次数至少为 \sim N\lg N（假设输入元素的所有排列的出现概率是均等的）。提示：比较次数至少是比较树的外部路径的长度（根结点到所有叶子结点的路径长度之和），当树平衡时该值最小。

TODO 2.2.14　归并有序的队列。编写一个静态方法，将两个有序的队列作为参数，返回一个归并后的有序队列。

TODO 2.2.15　自底向上的有序队列归并排序。用下面的方法编写一个自底向上的归并排序：给定 N 个元素，创建 N 个队列，每个队列包含其中一个元素。创建一个由这 N 个队列组成的队列，然后不断用练习 2.2.14 中的方法将队列的头两个元素归并，并将结果重新加入到队列结尾，直到队列的队列只剩下一个元素为止。

TODO 2.2.16　自然的归并排序。编写一个自底向上的归并排序，当需要将两个子数组排序时能够利用数组中已经有序的部分。首先找到一个有序的子数组（移动指针直到当前元素比上一个元素小为止），然后再找出另一个并将它们归并。根据数组大小和数组中递增子数组的最大长度分析算法的运行时间。

TODO 2.2.17　链表排序。实现对链表的自然排序（这是将链表排序的最佳方法，因为它不需要额外的空间，且运行时间是线性对数级别的）。

TODO 2.2.18　打乱链表。实现一个分治算法，使用线性对数级别的时间和对数级别的额外空间随机打乱一条链表。

TODO 2.2.19　倒置。编写一个线性对数级别的算法统计给定数组中的“倒置”数量（即插入排序所需的交换次数，请见 2.1 节）。这个数量和 Kendal1 tau 距离有关，请见 2.5 节。

TODO 2.2.20　间接排序。编写一个不改变数组的归并排序，它返回一个 int[] 数组 perm，其中 perm[i] 的值是原数组中第 i 小的元素的位置。

TODO 2.2.21　一式三份。给定三个列表，每个列表中包含 N 个名字，编写一个线性对数级别的算法来判定三份列表中是否含有公共的名字，如果有，返回第一个被找到的这种名字。

TODO 2.2.22　三向归并排序。假设每次我们是把数组分成三个部分而不是两个部分并将它们分别排序，然后进行三向归并。这种算法的运行时间的增长数量级是多少？

实验题

TODO 2.2.23　改进。用实验评估正文中所提到的归并排序的三项改进（请见练习 2.2.11）的效果，并比较正文中实现的归并和练习 2.2.10 所实现的归并之间的性能。根据经验给出应该在何时为子数组切换到插入排序。

TODO 2.2.24　改进的有序测试。在实验中用大型随机数组评估练习 2.2.8 所做的修改的效果。根据经验用 N（被排序的原始数组的大小）的函数描述条件语句（a[mid] < =a[mid+1]）成立（无论数组是否有序）的平均次数。

TODO 2.2.25　多向归并排序。实现一个 k 向（相对双向而言）归并排序程序。分析你的算法，估计最佳的 k 值并通过实验验证猜想。

TODO 2.2.26　创建数组。使用 SortCompare 粗略比较在你的计算机上在 merge() 中和在 sort() 中创建 aux[] 的性能差异。

TODO 2.2.27　子数组长度。用归并将大型随机数组排序，根据经验用 N（某次归并时两个子数组的长度之和）的函数估计当一个子数组用尽时另一个子数组的平均长度。

TODO 2.2.28　自顶向下与自底向上。对于 N=10^3、10^4、10^5 和 10^6，使用 SortCompare 比较自顶向下和自底向上的归并排序的性能。

TODO 2.2.29　自然的归并排序。对于 N=10^3、10^6 和 10^9，类型为 Long 的随机主键数组，根据经验给出自然的归并排序（请见练习 2.2.16）所需要的遍数。提示：不需要实现这个排序（甚至不需要生成所有完整的 64 位主键）也能完成这道练习。
 */

it('2.2.12', () => {})
